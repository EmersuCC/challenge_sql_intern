CREATE TABLE IF NOT EXISTS CLIENTE (
	ID_CLIENTE SERIAL PRIMARY KEY,
	NOME VARCHAR ( 50 ) NOT NULL,
	IDADE INTEGER NOT NULL,
	STATUS_BLOQUEIO CHAR(1) NOT NULL DEFAULT 'A',
	LIMITE_CREDITO DECIMAL(10, 2) NOT NULL
);

CREATE TABLE IF NOT EXISTS FATURA (
	ID_FATURA SERIAL PRIMARY KEY,
	DATA_VENCIMENTO DATE NOT NULL,
	VALOR DECIMAL(10, 2) NOT NULL,
	STATUS CHAR(1) NOT NULL,
	ID_CLIENTE INTEGER REFERENCES CLIENTE(ID_CLIENTE)
);

CREATE TABLE IF NOT EXISTS PAGAMENTO (
	ID_PAGAMENTO SERIAL PRIMARY KEY,
	DATA_PAGAMENTO DATE,
	VALOR DECIMAL(10, 2),
	ID_FATURA INTEGER REFERENCES FATURA(ID_FATURA)
);

-- View para verificar clientes com idade entre 18 e 21 anos que possuem limite de crédito maior ou igual a 1000 reais.


CREATE OR REPLACE VIEW V_CLIENTE_LIM_BE_1000 AS
	SELECT
		COUNT(*) AS CLIENTE_1K_18_21
	FROM
		CLIENTE
	WHERE
		(IDADE BETWEEN 18
		AND 21)
		AND LIMITE_CREDITO >= 1000


-- View para verificar clientes que realizaram pagamento no dia do vencimento da Fatura.

CREATE OR REPLACE VIEW V_PAGAMENTO_DIA_VENCIMENTO AS
	SELECT
		F.DATA_VENCIMENTO,
		COUNT(*) AS QUANTIDADE
	FROM
		FATURA    F
		JOIN PAGAMENTO P
		ON F.ID_FATURA = P.ID_FATURA
	WHERE
		F.DATA_VENCIMENTO = P.DATA_PAGAMENTO
	GROUP BY
		F.DATA_VENCIMENTO;

-- View para verificar clientes que realizaram pagamento no dia anterior ao vencimento da Fatura.

CREATE OR REPLACE VIEW V_PAGAMENTOS_DIA_ANTERIOR AS
	SELECT
		C.ID_CLIENTE,
		F.VALOR,
		P.DATA_PAGAMENTO
	FROM
		CLIENTE   C
		JOIN FATURA F
		ON C.ID_CLIENTE = F.ID_CLIENTE JOIN PAGAMENTO P
		ON F.ID_FATURA = P.ID_FATURA
	WHERE
		P.DATA_PAGAMENTO = F.DATA_VENCIMENTO - INTERVAL '1 DAY';

-- View para verificar clientes que possuem faturas em atraso.

CREATE OR REPLACE VIEW V_CLIENTE_EM_ATRASO AS
SELECT
    C.ID_CLIENTE,
    C.NOME,
    F.VALOR,
    F.DATA_VENCIMENTO,
    CASE F.STATUS
        WHEN 'P' THEN 'Pago'
        WHEN 'A' THEN 'Atraso'
    END AS STATUS,
    EXTRACT(DAY FROM AGE(NOW(), F.DATA_VENCIMENTO)) AS DIAS_EM_ATRASO
FROM
    CLIENTE C
    JOIN FATURA F ON C.ID_CLIENTE = F.ID_CLIENTE
    LEFT JOIN PAGAMENTO P ON F.ID_FATURA = P.ID_FATURA
WHERE
    F.STATUS IN ('A', 'P')
    AND (P.DATA_PAGAMENTO IS NULL OR P.DATA_PAGAMENTO > F.DATA_VENCIMENTO)
ORDER BY
    DIAS_EM_ATRASO DESC;



-- View para listar os clientes que estão com faturas em atraso há mais de 3 dias

CREATE OR REPLACE VIEW V_ATRASO_PAGAMENTO_3DIAS AS
SELECT
    C.ID_CLIENTE,
    C.NOME,
    CASE
        WHEN EXTRACT(DAY FROM AGE(NOW(), F.DATA_VENCIMENTO)) > 3 THEN
            'Bloqueado'
        ELSE
            'Ativo'
    END AS STATUS_BLOQUEIO,
    F.ID_FATURA,
    F.VALOR,
    EXTRACT(DAY FROM AGE(NOW(), F.DATA_VENCIMENTO)) AS DIAS_EM_ATRASO
FROM
    CLIENTE C
    JOIN FATURA F ON C.ID_CLIENTE = F.ID_CLIENTE
    LEFT JOIN PAGAMENTO P ON F.ID_FATURA = P.ID_FATURA
WHERE
    F.STATUS = 'A'
    AND (P.DATA_PAGAMENTO IS NULL OR P.DATA_PAGAMENTO > F.DATA_VENCIMENTO)
ORDER BY
    DIAS_EM_ATRASO



-- Função/Trigger para bloquear clientes que possuem faturas em atraso há mais de 3 dias
CREATE OR REPLACE FUNCTION BLOQUEAR_CLIENTES() 
RETURNS TRIGGER AS $$
BEGIN
    UPDATE CLIENTE 
    SET STATUS_BLOQUEIO = 'B' 
    WHERE ID_CLIENTE IN (
        SELECT ID_CLIENTE
        FROM FATURA
        WHERE DATA_VENCIMENTO < (NOW() - INTERVAL '3 days')
        AND STATUS = 'A'
    );
    RETURN NEW;
END;
$$     
LANGUAGE PLPGSQL;


-- Trigger para a funcao de bloquear clientes

CREATE TRIGGER TRG_BLOQUEAR_CLIENTES 
AFTER INSERT OR UPDATE 
ON FATURA 
FOR EACH ROW 
EXECUTE FUNCTION BLOQUEAR_CLIENTES();




-- Função/Trigger para desbloquear clientes que possuem faturas em atraso há mais de 3 dias
CREATE OR REPLACE FUNCTION DESBLOQUEAR_CLIENTES() 
RETURNS TRIGGER AS $$
BEGIN
    UPDATE CLIENTE 
    SET STATUS_BLOQUEIO = 'A' 
    WHERE ID_CLIENTE IN (
        SELECT
            ID_CLIENTE
        FROM
            FATURA
        WHERE
            DATA_VENCIMENTO >= (NOW() - INTERVAL '3 days')
            AND STATUS = 'B'
    );
    RETURN NEW;
END;
$$     
LANGUAGE PLPGSQL;


-- Trigger para funcao de desbloquear clientes

CREATE TRIGGER TRG_DESBLOQUEAR_CLIENTES 
AFTER INSERT OR UPDATE 
ON FATURA 
FOR EACH ROW 
EXECUTE FUNCTION DESBLOQUEAR_CLIENTES();


-- Trigger para verificar limite de credito do cliente antes da abertura de uma nova fatura;
CREATE OR REPLACE FUNCTION VERIFICAR_LIMITE_CREDITO() 
RETURNS TRIGGER AS $$ 
    DECLARE 
        TOTAL_FATURAS_ABERTAS NUMERIC; 
    BEGIN 
        SELECT SUM(VALOR) INTO TOTAL_FATURAS_ABERTAS 
        FROM FATURA 
        WHERE ID_CLIENTE = NEW.ID_CLIENTE 
        AND STATUS = 'A'; 
        
        IF TOTAL_FATURAS_ABERTAS + NEW.VALOR > (
            SELECT LIMITE_CREDITO 
            FROM CLIENTE 
            WHERE ID_CLIENTE = NEW.ID_CLIENTE
        ) THEN 
            RAISE EXCEPTION 'Limite de crédito do cliente excedido'; 
        END IF; 
        
        RETURN NEW; 
    END; 
$$ LANGUAGE PLPGSQL;


-- Trigger para atualizar o limite de crédito do cliente quando a fatura estiver em atraso há mais de 3 dias

CREATE OR REPLACE FUNCTION ATUALIZAR_LIMITE_CREDITO()
RETURNS TRIGGER AS $$
BEGIN
    UPDATE CLIENTE 
    SET LIMITE_CREDITO = 0 
    WHERE CLIENTE.ID_CLIENTE IN (
        SELECT FATURA.ID_CLIENTE 
        FROM FATURA 
        JOIN CLIENTE ON CLIENTE.ID_CLIENTE = FATURA.ID_CLIENTE 
        WHERE FATURA.DATA_VENCIMENTO < (NOW() - INTERVAL '3 days') 
        AND FATURA.STATUS = 'A'
    );
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;



-- Trigger para verificar limite de credito do cliente antes da abertura de uma nova fatura;
CREATE TRIGGER TRG_ATUALIZAR_LIMITE_CREDITO
AFTER INSERT OR UPDATE ON FATURA
FOR EACH ROW
EXECUTE FUNCTION ATUALIZAR_LIMITE_CREDITO();


-- Function para rotina de excluir clientes sem fatura.
CREATE OR REPLACE FUNCTION EXCLUIR_CLIENTES_SEM_FATURA() RETURNS VOID AS $$
DECLARE 
    CLIENTE_ID INTEGER;
    TOTAL_EXCLUIDOS INTEGER := 0;
    CUR CURSOR FOR (
        SELECT ID_CLIENTE
        FROM CLIENTE
        WHERE NOT EXISTS (
            SELECT 1
            FROM FATURA
            WHERE FATURA.ID_CLIENTE = CLIENTE.ID_CLIENTE
        )
    );
BEGIN
    OPEN CUR;
    LOOP
        FETCH CUR INTO CLIENTE_ID;
        EXIT WHEN NOT FOUND;
        DELETE FROM CLIENTE
        WHERE ID_CLIENTE = CLIENTE_ID;
        TOTAL_EXCLUIDOS := TOTAL_EXCLUIDOS + 1;
        RAISE NOTICE 'Cliente ID % excluído', CLIENTE_ID;
    END LOOP;
    CLOSE CUR;
    RAISE NOTICE 'Total de clientes excluídos: %', TOTAL_EXCLUIDOS;
END;
$$ LANGUAGE PLPGSQL;




